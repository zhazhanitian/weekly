### 前言

Web缓存可以分为这几种：HTTP缓存、CDN缓存、服务器缓存、数据库数据缓存 。因为可能会直接使用副本免于重新发送请求或者仅仅确认资源没变无需重新传输资源实体，Web缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力

<br >

### 为什么要使用HTTP缓存

假设我们请求一次服务器，请求头大小1kb，响应头大小1kb，请求文件10kb

1次请求流量：12kb

10次请求流量：120kb

N次请求：12*N....

这只是假想的一次请求，但事实上的请求不仅是请求文件，请求客户端也会更多，那么问题就很明显：

1. 客户端每次都要请求服务器，浪费流量
2. 服务器每次都得提供查找，下载，请求用户基础如果较大，服务器存在较大压力
3. 客户端每次请求完都要进行页面渲染，用户体验较差

基此是否可以将请求的文件存放起来使用，比如使用http缓存

<br >

### 基础概念

* **Cache-Control**

  请求/响应头，缓存控制字段，可以说是控制http缓存的最高指令，要不要缓存也是它说了算

  属性值如下：

  * no-store：所有内容都不缓存
  * no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新，它是个比较高贵的存在，因为它只用不过期的缓存
  * max-age=x(单位秒)： 请求缓存后的X秒不再发起请求，属于http1.1属性，与下方Expires(http1.0属性)类似，但优先级要比Expires高
  * s-maxage=x(单位秒) ：代理服务器请求源站缓存后的X秒不再发起请求，只对CDN缓存有效
  * public：客户端和代理服务器（CDN）都可缓存
  * private：只有客户端可以缓存

* **Expires**

  响应头，代表资源过期时间，由服务器返回提供，GMT格式日期，是http1.0的属性，在与max-age(http1.1)共存的情况下，优先级要低。Expires 过期控制不稳定，它是HTTP/1.1之前版本遗留的通用首部字段，因为浏览器端可以随意修改时间，导致缓存使用不精准，所以仅作为于HTTP/1.0的向后兼容而使用，现在大多数使用Cache-Control替代

* **Last-Modified**

  响应头，资源最新修改时间，由服务器告诉浏览器

* **if-Modified-Since**

  浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间（其实就是上次服务器给的Last-Modified，请求又还给服务器对比）。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了

  * 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
  * 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

* **Etag**

  服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

  但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了

* **if-None-Match**

  请求头，缓存资源标识，再次请求服务器时，浏览器的请求报文头部会包含此字段（其实就是上次服务器给的Etag），后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比

  * 不同，说明资源被改动过，则响应整个资源内容，返回状态码200
  * 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304

<br >

###  http缓存发展

* **Expires--让服务器与浏览器约定一个文件过期时间(GMT时间格式)**

  第一次请求

  浏览器：服务器服务器，我现在需要一个a.js文件，帮我找找，然后给我

  服务器：次次找我要，烦不烦，文件给你可以，我们约定个时间（Expires），时间没到别来烦我了，返回了a.js以及过期时间（Expires）

  <img src="https://qiniu-app.qtshe.com/1sd.png" style="float: left" />

  后续请求.....

  浏览器会先对比当前时间是否已经大于Expires也就是判断文件是否超过了约定的过期时间

  时间没过，不发起请求，直接使用本地缓存

  时间过期，发起请求，继续上述的浏览器与服务器的谈话日常

  **问题：假设Expires已过期，浏览器再次请求服务器，但a.js相比上次并未做任何改变，那这次请求我们是否通过某种方式加以避免**

<br >

* **Last-Modified与if-Modified-Since--让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比**

  第一次请求

  浏览器：服务器服务器，我现在需要一个a.js，你找到了给我，顺便给我个过期时间，时间没到我保证不烦你！

  服务器：哈卖批，行，过期时间我给你，另外再给你一个文件最新修改时间Last-Modified，到时候文件过期了咱两核对文件修改时间，对得上你就别烦我，返回a.js+Expires+Last-Modified

  <img src="https://qiniu-app.qtshe.com/2sd.png" style="float: left;" />

  后续请求....

  Expires未过期，浏览器机智的使用本地缓存，免得挨打

  Expires过期，服务器带上了文件最新修改时间if-Modified-Since(也就是上次请求服务器返回的Last-Modified)，服务器将if-Modified-Since与Last-Modified做了个对比

  if-Modified-Since 与Last-Modified不相等，服务器查找了最新的a.js，同时再次返回Expires与全新的Last-Modified

  if-Modified-Since 与Last-Modified相等，服务器返回了状态码304，文件没修改过，你还是用你的本地缓存

  如下图，请求头与响应头文件修改时间相同，所以返回了304，使用本地缓存

  ![](https://qiniu-app.qtshe.com/123asd.png)

<br >

  **问题：浏览器端可以随意修改Expires，Expires不稳定，Last-Modified只能精确到秒，假设文件是在1s内发生变动，Last-Modified无法感知到变化，这种情况下浏览器永远拿不到最新的文件(假想极端情况)**

<br >

* **Etag与If-None-Match--让服务器与浏览器在过期时间Expires+Last-Modified的基础上，再增加一个文件内容唯一对比标记**

  第一次请求

  浏览器：服务器服务器，你懂得~~~~~~

  服务器：我不懂！a.js我给你，过期时间我也给你，再给你一个max-age=60(单位秒)，Last-Modified你也给我收好，再加一个文件内容唯一标识符Etag

  后续请求....

  60S内，不发起请求，直接使用本地缓存。（max-age=60代表请求成功缓存后的60S内不再发起请求，与Expires相似，同时存在max-age优先级要比Expires高，区别后面具体说）

  60S后，浏览器带上了if-Modified-Since 与If-None-Match(上次服务器返回来的Etag)发起请求，服务器对比If-None-Match与Etag(不对比if-Modified-Since与Last-Modified了，Etag优先级比Last-Modified高，毕竟更精准)

  If-None-Match与Etag不相等，说明a.js内容被修改过，服务器返回最新a.js与全新的Etag与max-age=60与Last-Modified与Expires

  If-None-Match与Etag相等，说明a.js文件内容无任何改变，返回304，告诉浏览器继续使用之前的本地缓存

  如下图，服务器Etag与If-None-Match相同，所以返回了状态码304，由于优先级问题，虽然也有if-Modified-Since与Last-Modified，但这里不会对两者做对比

  ![](https://qiniu-app.qtshe.com/123qwe.png)

<br >

  **问题：我们已经可以精确的对比服务器文件与本地缓存文件差异，但其实上面方案的演变都存在一个较大缺陷，** **max-age或Expires不过期，浏览器无法主动感知服务器文件变化**

<br >

* **整体流程**

<img src="https://qiniu-app.qtshe.com/fds123.png" style="zoom:67%;float: left;" />

<br >

* **总结**
  * HTTP 缓存依赖 URL 做唯一标识，不同的 URL 使用不同的缓存
  * Cache-Control 可以控制缓存策略，共有或者私有、缓存超时时长等
  * 通过 ETag 来标记数据指纹令牌，以此来确定响应数据是否更新
  * 应该为每个响应资源提供对应的缓存策略
  * 如果需要废弃之前的缓存，可以利用修改请求 URL 的方式，将数据指纹令牌追加在 URL 之后，以此来更新数据

<br >

### 最终方案

上述的流程始终存在一个问题，浏览器无法主动得知服务器上的资源变化

* **md5/hash缓存**

  通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题

  为什么这么做？实现原理是什么？

  前面说的http缓存方案，服务器与浏览器的文件修改时间对比，文件内容标识对比，前提基础都是建立在两者文件路径完全相同的情况下

  module/js/a-hash1.js与module/js/a-hash2.js是两个完全不同的文件，假想浏览器第一次加载页面，请求并缓存了module/js/a-hash1.js，第二次加载，文件指向变成了module/js/a-hash2.js，浏览器会直接重新请求a-hash2.js，因为这就是两个完全不同的文件，哪里还有什么http缓存文件对比，t通过这种做法，我们就可以从根本上解决过期时间没到浏览器无法主动请求服务器的问题。因此我们只需要在项目每次发布迭代将修改过的静态文件添加不同的MD5或hash标识就好啦

  这里不推荐缓存html文件，这样每次html加载渲染都可以感知文件变化，反正文件没变还是使用本地缓存，文件名都变了说明修改过，重新请求缓存就好了

  怎么改？一个个手动去修改？那不得累死。webpack提供了webpack-md5-hash插件，可以帮助开发者在项目发布时自动修改文件标识-文件指纹(搜文件指纹)原理差不多

* **CDN缓存**

  * **CDN**

    CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术(较为官方的说明)

    之前看到一个不错的例子，这里直接拿过来举例说说CDN

    假设多年前我们所在的城市只有一个火车站，每次春运，整个城市的人都得去这个火车站买票，人流量以及购票的需求可想而知有多大，为了缓解这个问题，城市的不同区，都出现了火车票代售点，这样每个区的人都可以就近买票了，火车站总站的压力就这样大大减轻了

    我们可以把每个区的售票点称之为CDN节点，也就是前面所说的代理服务器。简而言之，我们可以把CDN理解成浏览器与服务器之间的临时站点，它会替服务器处理一部分的浏览器请求，从而整理减轻总服务器的压力

    可以把CDN的价值归纳为：

    1. CDN通过分流的形式，大大减轻源站的访问压力

    2. 就像住的区比较偏远，每次买票要去城市中心，而这个区后来有了分站，火车票就可以就近购买一样。CDN也解决了跨地区访问问题，根本上为访问提供了加速

  * **CDN缓存**

    CDN边缘节点缓存数据，当浏览器请求，CDN将代替源站判断并处理此处请求

    第一次请求

    浏览器：服务器老哥，我需要a.js.

    服务器：（恼羞成怒）文件我给我小弟CDN了，以后你要这个找CDN，别找我了。成功返回a.js给CDN，CDN进行缓存，同时CDN返回给浏览器，浏览器自己也进行了缓存(cache-control的值public就是用在这的)。

    后续请求...

    浏览器：服务器，我缓存时间到了，赶紧给我对比下文件，看看要不要重新返回给我

    CDN节点：打住打住，叫唤啥呢，我大哥比较忙，文件给我看看，请求被代理了

    情况1：CDN节点自己缓存的文件未过期，于是返回了304给浏览器，打回了这次请求

    情况2：CDN节点发现自己缓存的文件过期了，为了保险起见，自己发起请求给了服务器(源站)，成功拿回了最新数据，然后再交给与了浏览器

    其实说到这，CDN缓存的问题也跟前面的http缓存一样，CDN缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件

    但是我们回归http缓存问题本质，缓存本身针对于更新频率不高的静态文件，其次，CDN缓存提供了分流以及访问加速其它优势条件。这里我问过同学，得到的信息是，CDN类似一个平台，是可以通过登录，手动更新CDN缓存的，变相解决了浏览器缓存无法手动控制的问题

    那么两种http缓存方案就说到这里了，接下来谈谈http缓存其它的一些问题和概念

<br >

### 强缓存与协商性缓存

* **强缓存：**不发起http请求，直接使用本地缓存，比如浏览器地址栏回车，使用浏览器的刷新按钮，在Expires（Cache-Control）或max-age生效的情况下，触发的都是强缓存
* **协商性缓存(弱缓存)：**在使用本地缓存前，先与服务器协商，核对缓存文件是否为最新。比如设置了cache-control=no-cache，不管你做任何操作，都会发起请求，这一类就是协商性缓存了

<br >

### 刷新的请求执行过程

* 浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

* F5 F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since

* Ctrl+F5 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来，于是客户端就完成了强行更新的操作
