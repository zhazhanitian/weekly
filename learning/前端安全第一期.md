#### 前言

国内最大的程序员社区CSDN网站的用户数据库被黑客公开发布，600万用户的登录名及密码被公开泄露，随后Tumblr 、12306、热血传奇等多家网站的用户密码被流传于网络，接连而来的账号泄漏事故引发众多网民对自己账号、密码等互联网信息被盗取的普遍担忧

这里对常见的前端安全问题进行一下学习及总结



#### SQL注入

##### 什么是sql注入

所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击．当应用程序使用输入内容来构造动态sql语句以访问[数据库]时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的字符串来传递，也会发生sql注入。 黑客通过SQL注入攻击可以拿到网站[数据库]的访问权限，之后他们就可以拿到网站数据库中所有的数据，恶意的黑客可以通过SQL注入功能篡改数据库中的数据甚至会把数据库中的数据毁坏掉。做为网络开发者的你对这种黑客行为恨之入骨，当然也有必要了解一下SQL注入这种功能方式的原理并学会如何通过代码来保护自己的网站数据库

简而言之，Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一



##### sql注入产生原因

sql注入攻击是利用是指利用设计上的漏洞，在目标服务器上运行Sql语句以及进行其他方式的攻击，动态生成Sql语句时没有对用户输入的数据进行验证是Sql注入攻击得逞的主要原因。对于Java数据库连接JDBC而言，SQL注入攻击只对Statement有效，对PreparedStatement是无效的，这是因为PreparedStatement不允许在不同的插入时间改变查询的逻辑结构
如验证用户是否存在的SQL语句为：用户名'and pswd='密码，如果在用户名字段中输入: 'or 1=1或是在密码字段中输入:'or 1=1；将绕过验证，但这种手段只对只对Statement有效，对PreparedStatement无效

相对Statement有以下优点：

* 防注入攻击
* 多次运行速度快
* 防止数据库缓冲区溢出
* 代码的可读性可维护性好

这四点使得PreparedStatement成为访问数据库的语句对象的首选，缺点是灵活性不够好，有些场合还是必须使用Statement

Sql 注入带来的威胁主要有如下几点

- 猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息
- 绕过认证，列如绕过验证登录网站后台
- 注入可以借助数据库的存储过程进行提权等操作



##### sql注入原理

SQL注射能使攻击者绕过认证机制，完全控制远程服务器上的数据库。 SQL是结构化查询语言的简称，它是访问数据库的事实标准。目前，大多数Web应用都使用SQL数据库来存放应用程序的数据。几乎所有的Web应用在后台 都使用某种SQL数据库。跟大多数语言一样，SQL语法允许数据库命令和用户数据混杂在一起的。如果开发人员不细心的话，用户数据就有可能被解释成命令， 这样的话，远程用户就不仅能向Web应用输入数据，而且还可以在数据库上执行任意命令了

   SQL注入式攻击的主要形式有两种。一是直接将代码插入到与SQL命令串联在一起并使得其以执行的用户输入变量。上面笔者举的例子就是采用了这种方法。由于其直接与SQL语句捆绑，故也被称为直接注入式攻击法。二是一种间接的攻击方法，它将恶意代码注入要在表中存储或者作为原书据存储的字符串。在存储的字符串中会连接到一个动态的SQL命令中，以执行一些恶意的SQL代码。注入过程的工作方式是提前终止文本字符串，然后追加一个新的命令。如以直接注入式攻击为例。就是在用户输入变量的时候，先用一个分号结束当前的语句。然后再插入一个恶意SQL语句即可。由于插入的命令可能在执行前追加其他字符串，因此攻击者常常用注释标记“—”来终止注入的字符串。执行时，系统会认为此后语句位注释，故后续的文本将被忽略，不被编译与执行

基于此，SQL注入的产生原因通常表现在以下几方面

* 转义字符处理不合适
* 不安全的数据库配置
* 不合理的查询集处理
* 不当的错误处理
* 多个提交处理不当



##### SQL注入攻击的总体思路

1. 发现SQL注入位置
2. 判断后台数据库类型
3. 确定XP_CMDSHELL可执行情况
4. 发现WEB虚拟目录
5. 上传ASP木马
6. 得到管理员权限

###### SQL注入漏洞的判断

一般来说，SQL注入一般存在于形如：http: //xxx.xxx.xxx/abc.asp?id=XX 带有参数的asp或者动态网页中，有时一个动态网页中可能只有一个参数，有时可能有N个参数，有时是整型参数，有时是字符串型参数，不能一概而论。总之只要是带有参数的动态网页且此网页访问了数据库，那么就有可能存在SQL注入，如果程序员没有安全意识，不进行必要的字符过滤，存在SQL注入的可能性就非常大

###### 区分数据库服务器类型

一般来说，ACCESS与SQL－SERVER是最常用的数据库服务器，尽管它们都支持T－SQL标准，但还有不同之处，而且不同的数据库有不同的攻击方法，必须要区别对待

* 利用数据库服务器的系统变量进行区分

  SQL－SERVER有user,db_name()等系统变量，利用这些系统值不仅可以判断SQL-SERVER，而且还可以得到大量有用信息

* 利用系统表

  ACCESS的系统表是msysobjects,且在WEB环境下没有访问权限，而SQL-SERVER的系统表是sysobjects,在WEB环境下有访问权限

###### 确定XP_CMDSHELL可执行情况

若当前连接数据的帐号具有SA权限，且master.dbo.xp_cmdshell扩展存储过程(调用此存储过程可以直接使用操作系统的shell)能够正确执行

###### 发现WEB虚拟目录

只有找到WEB虚拟目录，才能确定放置ASP木马的位置，进而得到USER权限，有两种方法比较有效

* 根据经验猜解，一般来说，WEB虚拟目录是：c:\inetpub\wwwroot; D:\inetpub\wwwroot; E:\inetpub\wwwroot等，而可执行虚拟目录是：c:\inetpub\scripts; D:\inetpub\scripts; E:\inetpub\scripts等
* 遍历系统的目录结构，分析结果并发现WEB虚拟目录

###### 上传ASP木马

所谓ASP木马，就是一段有特殊功能的ASP代码，并放入WEB虚拟目录的Scripts下，远程客户通过IE就可执行它，进而得到系统的USER权限，实现对系统的初步控制，上传ASP木马一般有两种比较有效的方法：

* 利用WEB的远程管理功能

  许多WEB站点，为了维护的方便，都提供了远程管理的功能；也有不少WEB站点，其内容是对于不同的用户有不同的访问权限。为了达到对用户权限的控制，都有一个网页，要求用户名与密码，只有输入了正确的值，才能进行下一步的操作,可以实现对WEB的管理，如上传、下载文件，目录浏览、修改配置等
  因此，若获取正确的用户名与密码，不仅可以上传ASP木马，有时甚至能够直接得到USER权限而浏览系统，上一步的“发现WEB虚拟目录”的复杂操作都可省略

* 利用表内容导成文件功能

  SQL有BCP命令，它可以把表的内容导成文本文件并放到指定位置。利用这项功能，我们可以先建一张临时表，然后在表中一行一行地输入一个ASP木马，然后用BCP命令导出形成ASP文件

###### 得到系统的管理员权限

ASP木马只有USER权限，要想获取对系统的完全控制，还要有系统的管理员权限，怎么办呢，提升权限的方法有很多种

* 上传木马，修改开机自动运行的.ini文件(它一重启，便死定了)
* 复制CMD.exe到scripts，人为制造UNICODE漏洞
* 下载SAM文件，破解并获取OS的所有用户名密码





#### CSRF（跨站请求伪造）

##### 什么事CSRF攻击

跨站请求伪造（CSRF）攻击强迫终端用户在他们身份被认证的情况下执行对于目标应用未知的操作（恶意的）。CSRF 攻击一般针对状态更改请求，而不是数据被盗，因为攻击者无法查看对伪造请求的响应。通过社会工程的（例如通过电子邮件或聊天发送链接）方法，攻击者可以欺骗 Web 应用程序的用户执行攻击者选择的操作。如果受害者是普通用户，则成功的 CSRF 攻击可以强制用户执行状态更改请求，例如转账，更改其电子邮件地址等。如果受害者是管理帐户，CSRF 可能会危及整个 Web 应用程序

值得注意的一点是 CSRF（跨站请求伪造）攻击经常与 XSS（跨站脚本）攻击（特别是反射性 XSS 攻击）混淆，两者虽然都是跨站，但并未有实际联系，利用方式也不尽相同。XSS 攻击通常是在合法的网络应用中注入恶意的内容为受害者提供服务。注入的内容会被浏览器执行，因此恶意脚本会执行。CSRF 的攻击通常是让目标用户在不知情的情况下执行一个操作（比如转账，表单提交），如果当前目标用户的还是已授权状态，那么这些操作就有可能会执行成功。可以这么理解，CSRF 就是利用用户合法的身份在用户不知情的情况下执行一些操作。而 XSS 则是在合法的网站注入恶意的内容，需要或者不需要用户交互即可执行恶意脚本，从而实现攻击。虽然两者并无太多相同之处，但是 XSS 漏洞会导致 CSRF 的某些防护措施失效，因此做好 XSS 的防护对于 CSRF 的防护也是很有意义的



##### CSRF 的工作原理

CSRF 攻击是通过让一个已授权的用户的浏览器向应用发起一个恶意请求（用户尚不知情的情况）。只要用户的身份已被验证过且实际的请求已经通过用户的浏览器发送到目标应用，应用无法知道情况的来源是否是一个有效的交易或者这个用户是在知情的情况下点击这个链接。通过 CSRF 攻击，攻击者可以让受害者执行一些他们不知情的操作，比如，登出，购买操作，改变账户信息或者其它目标攻击应用提供的服务

###### CSRF攻击示意图

前端访问服务器时没有同服务器做安全验证

<img src="https://qiniu-app.qtshe.com/x22.png" style="zoom:40%;" />

##### CSRF 攻击的对象

CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据

所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护



##### 防范 CSRF 攻击

* 基于 token 的防护措施

  这种防护措施是针对 CSRF 攻击最通用也是最推荐的防护手段。这种防护可以通过有状态的（同步口令模式）或者无状态（基于加密/哈希的口令模式）。很多框架已经自带实现同步口令模式防御，因此强烈推荐使用框架自带的防护措施。如果外部组件实现的 CSRF 防御也可以使用。基于加密的口令模式利用的是加密，而不是基于口令的验证。这比较适用于不希望保持服务端状态的应用。在认证成功之后，服务器会生成一个特殊的口令，包括用户的 ID，时间戳以及服务器端生成的随机数。这个口令只有被解密后才能够获取用户的 ID 以及时间戳，从而进行验证。基于 HMAC 的口令模式是一种加密函数能够帮助保证消息的完整性。这是另外一种不需要保持服务端状态的防护措施，和基于加密的口令模式类似，但有两点不同：

  * 使用强 HMAC 函数而不是普通的加密函数来生成口令
  * 包含一个称为“操作”的额外字段来表示操作的目的（比如可能是 form tag/ajax call)

* 自动 CSRF 防护技术

  基于口令的防护技术被广泛地使用，这种技术有一个最大的问题就是需要人工去添加。如果开发者忘记对某个操作添加口令，那么就有可能遭受 CSRF 攻击。为了避免这种情况，可以通过自动化添加口框来避免 CSRF 攻击

  * 对于默认表单标签/ajax 调用通过编写包装器（在使用时自动添加令牌）并教育你的开发人员使用这些包装器而不是标准标签。虽然这种方法比纯粹依赖开发人员添加令牌更好，但也容易被人忘记。 默认情况下，当使用自定义 `` 标记时，Spring Security 会使用此技术添加 CSRF 令牌，你可以在验证其在你正在使用的 Spring Security 版本中启用并正确配置后选择使用
  * 在使用的 Web 渲染框架中编写一个钩子（可以捕获流量并在渲染给客户之前将令牌添加到容易遭受 CSRF 攻击的资源）。由于很难分析特定响应何时进行任何状态更改（因此需要令牌），因此你可能希望在所有容易遭受 CSRF 攻击的资源中包含令牌（例如：在所有 POST 响应中包含令牌）。这是一种推荐的方法，但你需要考虑它可能产生的性能成本
  * 通过客户端脚本在用户浏览器中渲染页面时，获取在客户端自动添加的令牌（CSRF Guard 使用此方法）。你需要考虑任何可能的 JavaScript 劫持攻击



##### 验证 HTTP Referer 字段

根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http: //bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求

这种方法的显而易见的好处就是简单易行，网站普通开发人员不需操心 CSRF 的漏洞，只需在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别对于当前现有系统，不需改变当前系统的任何已有代码和逻辑，没有风险，非常便捷

然而，这种方法并非万无一失。Referer 的值由浏览器提供，虽然 HTTP 协议上有明确要求，但每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已有一些方法可篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可通过验证，从而进行 CSRF 攻击

即便是使用最新浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们的隐私权，特别有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户访问



##### 在 HTTP 头中自定义属性并验证

这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去

然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的



##### 验证标准头的 origin

这种防护措施包含两个步骤，都依赖于对于 HTTP 请求头值的检查

* 获取请求的 origin 来自于哪里（源 origin），可以通过 Origin 或者 Refer 来获取

* 获取请求的目标 origin

在服务器端，对这两步都应该进行验证，如果符合的话，那么请求就被认为是合法请求（同源请求），如果不符合的，请求就会被丢弃（意味着请求是跨域的）。这种方法之所以有效是因为通过程序化方式（比如 XSS 中的 JS）无法修改这些值，只有浏览器可以设置



##### 错误阻止 CSRF 攻击的认知

以下措施可能只能增加 CSRF 攻击的难度或者根本无法阻止 CSRF 攻击：

- 使用加密 cookie（基本没啥用）
- 只接受 POST 请求（CSRF 也可以构造 POST 请求）
- 多步骤交易（攻击者懂你的业务逻辑就可以了）
- URL 重写（会引入新的问题）
- HTTPS （虽然不能直接起作用，但是上 HTTPS 准没错）