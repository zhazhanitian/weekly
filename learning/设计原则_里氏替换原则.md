## 里氏替换原则（Liskov Substitution Principle， LSP）

#### 简介

里氏替换原则，就是对开发封闭原则进行补充，讲的是基类和子类的关系

每个开发人员在使用别人的组件时，只需知道组件的对外裸露的接口，那就是它全部行为的集合，至于内部到底是怎么实现的，无法知道，也无须知道

所以，对于使用者而言，它只能通过接口实现自己的预期，如果组件接口提供的行为与使用者的预期不符，错误便产生了。里氏替换原则就是在设计时避免出现派生类与基类不一致的行为

<br >

#### 定义

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范

换而言之OCP 作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性

‘抽象’是语言提供的功能，‘多态’由继承语义实现

<br >

#### 分析

假设有一个类是鸟，定义了一个 fly 的方法，可以在天空飞。而儿鸵鸟也是鸟，并且继承了这个鸟类。但是鸵鸟不会飞，如果把使用飞鸟的地方替换成鸵鸟，那么程序就会挂掉，当然也可以在鸵鸟类破坏性地重写这个 fly 方法，但这显然违背了鸟类的设计意图

定义包含四层意思

* 子类可以实现父的抽象方法，但不能覆写父类的非抽象方法。 父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏
*  子类中可以增加自己特有的方法
*  覆写或实现父类的方法时，输入参数可以被放大
* 覆写或实现父类的方法时输出结果可以被缩小

简而言之就是推荐重载而不是重写，需要重写的地方，最好是定义一个抽象方法或者接口，在子类实现。当然实际情况下，使用重写是不可避免的，但是不要进行破坏性的重写。 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生‘畸变’，则建议断开父子继承关系，在两者基础上新增一个更高级的抽象类，或者使用依赖、聚集、组合等关系代替继承

<br >

#### 式例

```js
// 抽象枪类
class AbstractGun {
    shoot(){
        throw 'Abstract methods cannot be called'
    }
}

// 步枪
class Rifle extends AbstractGun {
    shoot(){
        console.log('步枪射击->')
    }
}

// 狙击枪
class AUG extends Rifle {
    zoomOut(){
        console.log('通过放大镜观察')
    }
  
    shoot(){
        console.log('AUG射击->')
    }
}

// 士兵
class Soldier {
    constructor(){
        this.gun = null
    }
  
    setGun(gun){
        this.gun = gun
    }
  
    killEnemy(){
        if(!this.gun){
            throw '需要给我一把枪'
            return
        }
        console.log('士兵开始射击->')
        this.gun.shoot()
    }
}

// 狙击手
class Snipper extends Soldier {
    killEnemy(aug){
        if(!this.gun){
            throw '需要给我一把枪'
            return
        }
        this.gun.zoomOut()
        this.gun.shoot()
    }
}

let soldier = new Soldier()
soldier.setGun(new Rifle())
soldier.killEnemy()

let snipper = new Snipper()
// 分配狙击枪
snipper.setGun(new AUG())
snipper.killEnemy()

snipper.setGun(new Rifle())
snipper.killEnemy() // this.gun.zoomOut is not a function
```

从上述代码中可以看出，子类和父类之间关系，子类方法一定是等于或大于父类的方法。子类能够出现的地方父类不一定能出现，但是父类出现的地方子类一定能够出现，这意味着子类必须保持与父类行为的兼容，在重写一个方法时，你要对基类行为进行扩展，而不是将其完全替换

<br >

#### 形式要求

与有着多种解释方式的其他设计模式不同， 替代原则包含一组对子类(特别是其方法)的形式要求

* 子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象

  假设某个类有个方法用于给猫咪喂食: feed(Cat c) ，客户端代码总是会将“猫(cat)” 对象传递给该方法

  * 好的方式：假如创建了一个子类并重写了前面的方法， 使其能够给任何“动物(animal，即‘猫’的超类)”喂食: feed(Animal c) 

    如果现在将一个子类对象而非超类对象传递给客户端代码，程序仍将正常工作

    该方法可 用于给任何动物喂食， 因此它仍然可以用于给传递给客户端的任何“猫”喂食

  * 不好的方式：创建了另一个子类且限制喂食方法仅接受 “孟加拉猫 (BengalCat， 一个 ‘猫’ 的子类)”:feed(BengalCat c) 

    如果用它来替代链接在某个对象中的原始类，客户端中会发生什么呢? 由于该方法只能对特殊种类的猫进行喂食， 因此无法为传递给客户端的普通猫提供服务，从而将破坏所有相关的功能

* 子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配

  假如一个类中有一个方法buyCat(): Cat，客户端代码执行该方法后的预期返回结果是任意类型的“猫”

  * 好的方式：子类将该方法重写为: buyCat(): BengalCat

    客户端将获得一只“孟加拉猫”， 自然它也是一只“猫”， 因此一切正常

  * 不好的方式：子类将该方法重写为: buyCat(): Animal 

    现在客户端代码将会出错，因为它获得的是自己未知的动物种类 ( 短 吻 鳄 ? 熊 ?)，不适用于为一只“ 猫 ”而设计的结构

* 子类中的方法不应抛出基础方法预期之外的异常类型

  换句话说，异常类型必须与基础方法能抛出的异常或是其子类别相匹配。这条规则源于一个事实:客户端代码的 try-catch代码块针对的是基础方法可能抛出的异常类型。因此，预期之外的异常可能会穿透客户端的防御代码，从而使整个应用崩溃

* 子类不应该加强其前置条件

  基类的方法有一个int类型的参数。如果子类重写该方法时， 要求传递给该方法的 参数值必须为正数(如果该值为负则抛出异常)，这就是加强了前置条件。客户端代码之前将负数传递给该方法时程序能够正常运行，但现在使用子类的对象时会使程序出错

* 子类不能削弱其后置条件

  假如某个类中有个方法需要使用数据库，该方法应该在接收到返回值后关闭所有活跃的数据库连接

  创建一个子类并对其进行了修改，使得数据库保持连接以便重用。但客户端可能对你的意图一无所知。由于它认为 该方法会关闭所有的连接，因此可能会在调用该方法后就马 上关闭程序，使得无用的数据库连接对系统造成“污染”

* 超类的不变量必须保留

  这很可能是所有规则中最不“形式” 的一条。不变量是让对象有意义的条件。例如，猫的不变量是有四条腿、一条尾巴和能够喵喵叫等。不变量让人疑惑的 地方在于它们既可通过接口契约或方法内的一组断言来明确定义，又可暗含在特定的单元测试和客户代码预期中

  不变量的规则是最容易违反的，因为你可能会误解或没有意识到一个复杂类中的所有不变量。因此，扩展一个类的最安全做法是引入新的成员变量和方法，而不要去招惹超类中已有的成员。当然在实际中，这并非总是可行

* 子类不能修改超类中私有成员变量的值

  有些编程语言允许通过反射机制来访问类的私有成员，还有一些语言(Python和JavaScript)没有对私有成员进行任何保护

<br >

#### 优点

- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
- 提高代码的重用性
- 子类可以形似父类，但是又异于父类
- 提高代码的可扩展性，实现父类的方法就可以了，许多开源框架的扩展接口都是通过继承父类来完成
- 提高产品或项目的开放性

<br >

#### 缺点

* 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法
* 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束
* 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果(—大段的代码需要重构)

<br >

#### 总结

用一句话来形容LSP，当无法根据 Is-A 来判断继承关系是否合理时，应该思考如何进行下一步抽象，从而避免让继承产生二义性

借用极限编程的理念来讲：将我们认同的有效软件开发原理和实践应用到极限。我们在做面向对象设计时，不妨拿起LSP这个现成的工具，帮助我们有效地减少继承的滥用、模糊意图等设计缺陷，提升软件设计