## 简介

依赖倒置原则是系统解耦的重要原则，遵循它可以让我们的系统更加健壮

> 因为JavaScript是动态语言，所以不需要去为了解耦而抽象，所以抽象不应依赖于细节这个改变在JavaScript里没有太大的影响，但高层模块不应依赖于低层模块却有很大的影响

<br >

<br >

## 依赖倒置原则

* High level modules should not depend upon low level modules.Both should depend upon abstractions. 

  高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的）

* Abstractions should not depend upon details. 

  抽象不应该依赖细节（接口或抽象类不依赖于实现类）

* Details should depend upon abstractions. 

  细节应该依赖抽象（实现类依赖接口或抽象类）

<br >

#### 核心思想

依赖倒置原则的主要思想是要面向接口编程，不要面向具体实现编程

该原则的第一部分是关于高层模块和低层模块之间的耦合方式，在传统的分成架构中，高层模块（封装了程序的核心业务逻辑）总依赖于低层的一些模块（一些基础点）。当应用依赖倒置原则的时候，关系就反过来了。和高层模块依赖于低层模块不同，依赖倒置是让低层模块依赖于高层模块里定义的接口。举例来说，如果要给程序进行数据持久化，传统的设计是核心模块依赖于一个持久化模块的API，而根据依赖倒置原则重构以后，则是核心模块需要定义持久化的API接口，然后持久化的实现实例需要实现核心模块定义的这个API接口

<img src="https://qiniu-image.qtshe.com/0CD83296.png" style="zoom:60%;float:left;" />

抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险

<br >

#### 概念解析

* 上层、下层

  上层、下层是一类概念，在计算机的设计中，分层是常见的任务分解方法，每一层都使用下层提供的功能，又为更上层提供自己的功能。依赖倒置原则要求在设计层间通信、交互标准时，不应依赖于某个下层，而是应该依赖于抽象，这样上下层之间就没有强耦合，如果两个实现都遵循了同样的抽象，则可以在上层无感知的情况下替换下层实现

* 抽象、实现

  抽象、实现是一类概念，抽象是对同一类任务本质属性的表达，实现则是具体每一类任务的细节的表达。依赖倒置原则说明实现应该依赖于抽象，是因为实现是对抽象骨架的填充，而抽象不应依赖于实现，是因为抽象是对本质的归纳，应去掉细节的干扰

* 依赖倒置原则倒置了什么

  从字面看依赖倒置当然是倒置了依赖，但核心是控制权的反转

<br >

#### 式例解析-作用

一个爱学习的渣渣同学现在正在学习设计模式和前端的课程，伪代码如下：

```js
const learn = () => {
		return {
        studyJSCourse: () => {
        	console.log('渣渣同学正在学习前端课程！')
        },
        studyDesignPatternCourse: () => {
        	console.log('渣渣同学正在学习设计模式课程！')
        }
    }
}
```

模拟上层调用一下

```js
const zhazha = learn()

zhazha.studyJSCourse()
zhazha.studyDesignPatternCourse()
```

* 有效控制影响范围

  由于渣渣同学热爱学习，随着学习兴趣的 “暴增”，可能会继续学习 AI（人工智能）的课程。这个时候，因为「业务的扩展」，要从底层实现到高层调用依次地修改代码

  我们需要在 learn 中新增 studyAICourse() 方法，也需要在高层调用中增加调用，这样一来，系统发布后，其实是非常不稳定的。显然在这个简单的例子中，我们还可以自信地认为，我们能 Hold 住这一次的修改带来的影响，因为都是新增的代码，我们回归的时候也可以很好地 cover 住，但实际的情况和实际的软件环境要复杂得多

  最理想的情况就是，我们已经编写好的代码可以 “万年不变”，这就意味着已经覆盖的单元测试可以不用修改，已经存在的行为可以保证保持不变，这就意味着「稳定」。任何代码上的修改带来的影响都是有未知风险的，不论看上去多么简单

<br >

* 增强代码可读性和可维护性

  另外一点，你有没有发现其实加上新增的 AI 课程的学习，他们三节课本质上行为都是一样的，如果我们任由这样行为近乎一样的代码在我们的类里面肆意扩展的话，很快我们的类就会变得臃肿不堪，等到我们意识到不得不重构这个类以缓解这样的情况的时候，或许成本已经变得高得可怕了

<br >

* 降低耦合

  《资本论》中有这样一段描述

  >  在商品经济的萌芽时期，出现了物物交换。假设你要买一个 iPhone，卖 iPhone 的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的 APP 来换他一头猪，他说换猪可以，但是得用一条金项链来换... 

  所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了

<br >

<br >

## 总结

在考虑依赖倒置原则的使用时，跟单一职责原则一样，需要注意使用的粒度。如果所有的代码都符合依赖倒置原则，那就过犹不及了

依赖倒置原则要求系统建立在抽象的基石之上，而不是实现的浮土之上。需求的变化是迅速而猛烈的，相应的就要求实现也是随时随地变化的，而其中的本质抽象却是相对不变的，如此系统就可以保持健壮，不会因外部纷扰左右摇摆

