## 前言

单一职责原则是最重要的设计原则，也是最抽象的设计原则。小到函数，大到平台的设计，都可以使用单一职责原则来指导。也正因为它的抽象性，没有一个统一的规则，不同的人即使是设计同一个功能，所划分的函数、类也都是不相同的

就一个类而言，应该仅有一个引起它变化的原因。在 JavaScript中，需要用到类的场景并不太多，单一职责原则更多地是被运用在对象或者方法级别上，因此讨论的是大多基于对象和方法

<br >

<br >

## 单一职责原则

SRP的定义几经迭代，最终被Robert C.Martin在《架构整洁之道》中定义为：任何一个软件模块都应该只对某一类行为者负责

单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一 个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过 多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。 此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职 责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏， 这种耦合性得到的是低内聚和脆弱的设计

 因此，SRP原则体现为：一个对象（方法）只做一件事情

<br >

#### 单一职责原则的目的

通过降低类的复杂度从而提高类的可读性，可扩展性

<br >

#### 何时应该分离职责

SRP 原则是所有原则中最简单也是最难正确运用的原则之一

要明确的是，并不是所有的职责都应该一一分离

一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开

另一方面，两个职责已经被耦 合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟

<br >

#### 判断指标

在《设计模式之美》专栏中王争老师给出的一些判断指标很具有指导意义，出现下面的情况就可能说明类的设计不满足单一职责原则

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性
- 类依赖的其他类过多，或依赖类的其他类过多，不符合高内聚、低耦合的思想
- 私有方法过多，就要考虑能否将私有方法独立到新的类中，设置为public，供更多的类使用，提高代码复用性。
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或只能用笼统的词语来命名，就说明类的职责可能不够清晰
- 类中大量的方法都是集中操作类的某几个属性，就可以考虑将这几个属性和对应的方法拆分出来

<br >

#### 使用场景

设计模式中的 SRP 原则，SRP原则在很多设计模式中都有着广泛的运用，例如

* 代理模式
* 迭代器模式
* 单例模式
* 装饰者模式

<br >

#### 式例

有这样一段代码，先遍历一个集合，然后往页面中添加一些 div，这些 div的 innerHTML分别对应集合里的元素

```js
const appendDiv = data => {
  for (let i = 0, l = data.length; i < l; i++) {
    const div = document.createElement( 'div' )
    div.innerHTML = data[i]
    document.body.appendChild(div)
  }
}

appendDiv([ 1, 2, 3, 4, 5, 6 ])
```

appendDiv 函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象 data 的职责，如果有一天 cgi返回的 data 数据格式从 array 变成了 object ，那我们遍历 data 的代码就会出现问题，必须改成 for ( var i in data ) 的方式，这时候必须去修改 appendDiv 里的
代码，否则因为遍历方式的改变，导致不能顺利往页面中添加 div节点

当把迭代聚合对象的职责单独封装在 each 函数中后，即使以后还要增加新的迭代方式，只需要修改 each 函数即可，使其只负责迭代聚合对象的单一职责， appendDiv 函数不会受到牵连

```js
// 式例：迭代器模式
const each = (obj, callback) => {
  let i = 0
  let length = obj.length
  let isArray = false

  if (isArray) {   
    for(; i < length; i++) {
      callback.call(obj[i], i, obj[i])
    }
  } else {     
    for( i in obj ){
      callback.call(obj[i], i, obj[i])
    }
  }

  return obj
}

const appendDiv = data => {
  each(data, (i, value) => {
    const oDiv = document.createElement('div')
    oDiv.innerHTML = value
    document.body.appendChild(oDiv)
  })
}

// 迭代类数组
appendDiv([1, 2, 3, 4, 5, 6])

// 迭代object对象
appendDiv({a: 1, b: 2, c: 3})
```

<br >

#### SRP 原则的优缺点

* 优点 

  * 降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度， 这有助于代码的复用，也有利于进行单元测试

  * 当一个职责需要变更的时候，不会影响到其他 的职责

* SRP 可以很好的将我们的功能、应用解耦，但是应该看到 SRP 存在的缺点，才可以更好的权衡自己的设计
  - 不明确。职责的含义没有明确界定，如何界定是门艺术
  - 无评判标准。界定出来的职责是好是坏？没有标准，只有经验
  - 易滥用。职责划分到最后可能就是一个接口一个方法，看似符合 SRP，实则是 SRP 的滥用
  - 函数、接口、类爆炸
  - 最明显的是会增加编写代码的复杂度。当我们按照职责把对象 分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度

<br >

<br >

## 总结

很多为了满足单一职责原则，把方法或类设计得十分单一，但是往往触及了“过犹不及”这个词，什么事都得有个度，如果为了追求单一职责原则而过度拆分，也会影响代码的可读性和可维护性，不管使用什么设计原则和模式，提高代码的可读性、可维护性、可扩展性、复用性，使代码高内聚、低耦合才是目的

要做一个符合SRP 原则的设计是很困难的，需要我们在实践中总结经验。对一个领域有了充分的了解，我们才能更加游刃有余的应用SRP 原则。同时不要滥用 SRP原则，编程是门艺术，设计更是一门艺术

