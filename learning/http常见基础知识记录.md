#### 前言

前面也了解了一些http相关的知识及体系，但是对一些专有名词没有做总结记录，导致过一久很多基础信息没法回顾，所以这里对一些常见的基础专业名词做记录，便于以后回顾学习

> 此文档将持续更新



#### 对称加密

对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法，有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要

对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高，不足之处是，交易双方都使用同样钥匙，安全性得不到保证

此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。而与公开密钥加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。在计算机专网系统中广泛使用的对称加密算法有DES和IDEA等。美国国家标准局倡导的AES即将作为新标准取代DES，常用加密算法有 DES算法，3DES算法，TDEA算法，Blowfish算法，RC5算法，IDEA算法等等



#### 非对称加密

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密

另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。
甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要

非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多

>这其中涉及到一些算法知识，作为扩展了解：**数学魔术**、**RSA算法**



#### HTTPS到底用的是对称加密还是非对称加密

##### 前言

这就涉及到另一个问题，为什么HTTPS比HTTP更安全，因为HTTP协议本身毫无安全性可言，当你访问一个纯HTTP的网站时，你发出去一个请求。在这个请求到达网站服务器的路途上，不管是你家的路由器、你楼层的路由器、你小区的路由器、你当地电信的机房里，再一直到那个网站的服务器机房之间的所有网络设备上，都有你请求的数据通过，只要中间有任何一个设备想要把数据记录下来，它可以没有任何阻力的做到，因为这些数据是完全可见、没有经过任何混淆和加密的。除了你的请求，还有网站的响应数据也完整地走了一遍这条链路，只是方向相反而已。从技术上说，你家买的电信宽带可以篡改网站响应给你的任何信息

HTTPS则完全避免了以上的问题，HTTPS相比HTTP，在请求前多了一个「握手」的环节。握手过程中，服务器会发出一张证书（带着公钥），握手完成后，你的请求先用密钥加密才会发出去，网站服务器的响应会先用密钥加密再传给你。由于整条链路上的节点拿到的数据都是加密过的，所以他们即无法分析出源数据的内容，也无法篡改这个加密过的数据

##### 解析

所以HTTPS的整体过程可以分为证书验证和数据传输两个阶段，具体的交互过程如下

![](https://qiniu-app.qtshe.com/1231323.jpg)

HTTPS 加解密流程如下：

- 用户在浏览器发起 HTTPS 请求（如 https:// www. mogu.com/），默认使用服务端的 443 端口进行连接。
- HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开。
- 服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端。
- 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续。
- 客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端。
- 服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key。
- 服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端。
- 客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文。
- 后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。



证书验证阶段

* 浏览器发起 HTTPS 请求
* 服务端返回 HTTPS 证书
* 客户端验证证书是否合法，如果不合法则提示告警

数据传输阶段

- 当证书验证合法后，在本地生成随机数
- 通过公钥加密随机数，并把加密后的随机数传输到服务端
- 服务端通过私钥对随机数进行解密
- 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

> 这里可能涉及到一个问题，为啥数据传输阶段使用对称加密，不使用非对称加密，这里主要涉及到算法相关内容，也就是上面提到的扩展**RSA算法**，假如服务器要传输给我们的是一整张网页，使用非对称加密的方法加密时，这个包含数百k的数据被转换成一个巨大的整数，再对它做e次方的操作，这将是非常耗时的（或者把数据拆成很多小整数，但要做e次方操作都是很耗时的）



#### 中间人劫持

过程大致如下：

- 你和服务器之间有一台邪恶的路由器M
- 当你给HTTPS网站的服务器发请求后，网站带着公钥P响应你
- 响应到达M，M拿到了P，但是并不把它交给你，而是自己伪造了一对公私钥MP和MS，并把MP给你
- 你拿到MP，以为是网站的公钥P，用它加密了S，再请求网站
- 请求到达M，M使用MS解开S，再用P加密S交给网站
- 就这样，邪恶路由器得到了S。至此你和网站的通信不再安全



#### 证书体系

中间人能劫持成功的本质，还是因为链路是不安全的，所以没有被加密的握手过程一定会有这个问题

目前解决问题的思路，是放在了公钥发放上，暂时绕开了这个问题，这就是证书体系（也是为什么要去找证书签发机构花钱购买证书的原因）

简单来说，一个HTTPS网站响应给我们的并不是一个公钥，而是证书，证书上包含了公钥，还包含了域名、签发机构、有效期、签名等等

因为这套证书体系已经根植于每一个操作系统里了，每一个操作系统里，都内置了数十张根证书，每个根证书都对应一个非常权威的证书签发机构，这些根证书上记录了各个机构的公钥，所以中间人也没办法做一个假证书

当网站找证书机构购买了一份合法的证书时，网站申请的证书上的公钥、域名、有效期等信息会被计算一次hash，然后证书机构用它的私钥给这个hash加密一次，这个加密结果就是证书的签名

当网站的合法HTTPS证书到达用户的电脑上，这个证书上带有签发机构的信息（具体来说应该是一条证书链），用户的浏览器会用这个签发机构对应的操作系统内置根证书上的公钥，去解开网站HTTPS证书的签名（由于运算结果有周期性，所以用私钥加密的信息可以用公钥解开），发现签名解开的hash与证书信息内容的hash一致，就可以证明证书是合法的了

当然，最后HTTPS的安全性仍然保证在『证书签发机构一定都是很有良心的』这种脆弱的基础上



#### 三次握手

<img src="https://qiniu-app.qtshe.com/123123.png" style="zoom:80%;" />



握手是数据传输的一个准备过程，只需要确保双方都可发可收，所以需要三次，也仅需三次就能完成





#### 四次挥手

<img src="https://qiniu-app.qtshe.com/asd1111.png" style="zoom:80%;" />



挥手是确保双方已经接收结束，所以需要四次，也仅需要四次就能完成



#### GET和POST两种基本请求方法的区别

##### w3schools给出的常规解答

- GET在浏览器回退时是无害的，而POST会再次提交请求

- GET产生的URL地址可以被Bookmark，而POST不可以

- GET请求会被浏览器主动cache，而POST不会，除非手动设置

- GET请求只能进行url编码，而POST支持多种编码方式

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 

- GET请求在URL中传送的参数是有长度限制的，而POST么有

- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制 

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 

- GET参数通过URL传递，POST放在Request body中

- GET产生一个TCP数据包，POST产生两个TCP数据包

  对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）

  而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

##### 来自大佬的解答

然而GET和POST本质上是没有区别的

GET和POST是什么？HTTP协议中的两种发送请求的方法

 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议

 HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接，GET和POST能做的事情是一样一样的，你要给GET加上request body，给POST带上url参数，技术上是完全行的通的

在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本

但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？

在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦